/* Index used for searching */
/*
   Fields used:
     url, name, type, filename, authors, routine name, comments, parameters,
     categories, and attributes
*/
title = "API documentation for POV-Ray destination";
subtitle = "Michael Galloy";
libdata = new Array();
libdataItem = 0;



libdata[libdataItem++] = new Array("./vis_povray.html", "vis_povray.pro", ".pro file in ./ directory", "vis_povray.pro", "", "", " Run POV-Ray on an .ini file and return an image of the result.    ", "", "system utility", "");
  
  
  libdata[libdataItem++] = new Array("./vis_povray.html#vis_povray", "vis_povray", "routine in vis_povray.pro", "vis_povray.pro", "", "vis_povray", " Run POV-Ray on an .ini file and return an image of the result.    ", "subset       set POV-Ray to only calculate the subset of the image specified by:    [x0, y0, xsize, ysize]         The returned image will be xsize by ysize and start at [x0, y0].        Rows and columns start at 0, but the origin is at the upper left        corner of the image.  format       output format: 'targus' or 'png'  cmd       povray invocation command  output       contents of the output log of the povray run  convert_location       location of the convert command; needed if convert is not in the shell        path  povray_location       location of the povray command; needed if povray is not in the shell        path  distributed       set to use mpiDL  tile_size       set of each tile to be sent to worker nodes when DISTRIBUTED is set  full_size       full size of the output image; used when DISTRIBUTED is set  n_procs       number of processors to use when DISTRIBUTED is set  basename       path and basename to .ini file  output       output basename (must be in same directory as basename)    ", "          -1", "    bytarr(3, m, n)    ");
  
  

libdata[libdataItem++] = new Array("./vis_xpovray.html", "vis_xpovray.pro", ".pro file in ./ directory", "vis_xpovray.pro", "", "", " GUI for manipulating a scene, including rotating, translating, and scaling a  model within it, then drawing the scene to POV-Ray input files.    To rotate the scene, click and drag using the left mouse button. To translate  the scene, click and drag the middle mouse button. To scale the scene, click  and drag the right mouse button (towards the center to shrink, away from the  center to expand).    The buttons in the toolbar write the POV-Ray files and spawn POV-Ray to run on  the exported files, respectively. Changing the size of the display via the  droplist or by dragging the corner of the window changes the size of the  output image.        ", "", "object graphics widget utility", "    * add run on subset feature (rubberband box)     * draw line to center when zooming    ");
  
  
  libdata[libdataItem++] = new Array("./vis_xpovray.html#vis_xpovray", "vis_xpovray", "routine in vis_xpovray.pro", "vis_xpovray.pro", "", "vis_xpovray", " Launch the POV-Ray application.    ", "model       model to rotate, translate, and scale; if not specified, gets first        model in the hierarchy  dimensions       size of graphics display  view       view to display    ", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovray__define.html", "visgrpovray__define.pro", ".pro file in ./ directory", "visgrpovray__define.pro", "", "", " This class is a POV-Ray object graphics destination. Drawing to this  destination will create one .inc file for every atom in the object graphics  hierarchy, a .pov file with the scene setup, and a .ini file with some  parameters like output dimensions.    ", "", "object graphics", "    To create a POV-Ray destination and drawing to it after creating an object     graphics hierarchy, view, just do the following:    pov = obj_new('VISgrPOVRay', file_prefix='cow-output/cow', dimensions=dims)   pov-&gt;draw, view      See the example attached to the end of this file as a main-level program     (only available if you have the source code version of this routine):    IDL&gt; .run visgrpovray__define      The example should produce a png file, cow.png:          ");
  
  
  libdata[libdataItem++] = new Array("./visgrpovray__define.html#visgrpovray::draw", "visgrpovray::draw", "routine in visgrpovray__define.pro", "visgrpovray__define.pro", "", "visgrpovray::draw", " Write the object graphics rooted at the specified scene or view.    ", "tree       scene or view object  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovray__define.html#visgrpovray::setProperty", "visgrpovray::setProperty", "routine in visgrpovray__define.pro", "visgrpovray__define.pro", "", "visgrpovray::setProperty", " Set properties.  ", "file_prefix       prefix to add to all output files; final result will be:    file_prefix + '.png'   dimensions       lonarr(2) specifying default width and height of output image; default        value is [400, 400]  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovray__define.html#visgrpovray::getProperty", "visgrpovray::getProperty", "routine in visgrpovray__define.pro", "visgrpovray__define.pro", "", "visgrpovray::getProperty", " Get properties.  ", "file_prefix       prefix to add to all output files; final result will be:    file_prefix + '.png'   dimensions       lonarr(2) specifying default width and height of output image; default        value is [400, 400]  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovray__define.html#visgrpovray::cleanup", "visgrpovray::cleanup", "routine in visgrpovray__define.pro", "visgrpovray__define.pro", "", "visgrpovray::cleanup", " Free resources.  ", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovray__define.html#visgrpovray::init", "visgrpovray::init", "routine in visgrpovray__define.pro", "visgrpovray__define.pro", "", "visgrpovray::init", " Create POV-Ray output destination for object graphics.    ", "file_prefix       prefix to add to all output files; final result will be:    file_prefix + '.png'   dimensions       default image size of the POV-Ray result  graphics_tree       graphics tree to tree if none is provided to draw method  ", "          -1", "    1 for success, 0 for failure    ");
  
  libdata[libdataItem++] = new Array("./visgrpovray__define.html#visgrpovray__define", "visgrpovray__define", "routine in visgrpovray__define.pro", "visgrpovray__define.pro", "", "visgrpovray__define", " Define instance variables.    ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovrayfinish__define.html", "visgrpovrayfinish__define.pro", ".pro file in ./ directory", "visgrpovrayfinish__define.pro", "", "", " Attribute class for VISgrPOVRayPolygons representing the surface properties  of objects.    ", "", "object graphics", "    To create a finish object using one of the finishes named in finish.inc,     use:    finish = obj_new('VISgrPOVRayFinish', finish_name='F_MetalB')      This can then be used in one of the VISgrPOVRay classes like:    cow = obj_new('VISgrPOVRayPolygon', x, y, z, polygons=polylist, $                  color=[150, 100, 20], shading=1, $                  shininess=25.0, ambient=[150, 100, 20], diffuse=[150, 100, 20], $                  finish=finish)      See the example attached to the end of this file as a main-level program     (only available if you have the source code version of this routine):    IDL&gt; .run visgrpovraygrid__define      This should produce:           ");
  
  
  libdata[libdataItem++] = new Array("./visgrpovrayfinish__define.html#visgrpovrayfinish::getProperty", "visgrpovrayfinish::getProperty", "routine in visgrpovrayfinish__define.pro", "visgrpovrayfinish__define.pro", "", "visgrpovrayfinish::getProperty", " Get properties.  ", "finish_name       name of a finish in finish.inc  ambient       controls the amount of ambient light that falls on the surface; increase        this amount to increase details in shadows; default value is 0.2  brilliance       controls the way that light intensity varies with incidence angle; the        default value is 1.0, higher values will cause the light to fall of less        at low and medium angles of incidence  diffuse       controls the amount of light from a light source falls on the surface;        low values of DIFFUSE will make the surface appear flat; default value        is 0.6  metallic       set to give the surface a more metallic appearance; default value is not        metallic  specular       controls specular highlights in conjunction with ROUGHNESS; controls the        brightness of the specular highlight; default value is 0.0  roughness       controls specular highlights in conjunction with SPECULAR; controls the        size of the specular highlight, small values make small, tight specular        highlights; default value is 0.05  reflection       amount the surface reflects; generally reflection and diffuse should        be inversely proportional; default value is 0.0  irid_amount       amount of contribution of iridescence to overall surface color, usually        0.1 to 0.5 is sufficient; iridescence is not used by default, but if any        iridescence property is set it is used; default value is 0.35  irid_thickness       thickness affects busyness of the iridescence, 0.25 to 1.0 yields best        results; iridescence is not used by default, but if any iridescence        property is set it is used; default value is 0.5  irid_turbulence       slightly difference way to affect thickness, 0.25 to 1.0 work best;        iridescence is not used by default, but if any iridescence property is        set it is used; default value is 0.5  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovrayfinish__define.html#visgrpovrayfinish::setProperty", "visgrpovrayfinish::setProperty", "routine in visgrpovrayfinish__define.pro", "visgrpovrayfinish__define.pro", "", "visgrpovrayfinish::setProperty", " Set properties.  ", "finish_name       name of a finish in finish.inc  ambient       controls the amount of ambient light that falls on the surface; increase        this amount to increase details in shadows; default value is 0.2  brilliance       controls the way that light intensity varies with incidence angle; the        default value is 1.0, higher values will cause the light to fall of less        at low and medium angles of incidence  diffuse       controls the amount of light from a light source falls on the surface;        low values of DIFFUSE will make the surface appear flat; default value        is 0.6  metallic       set to give the surface a more metallic appearance; default value is not        metallic  specular       controls specular highlights in conjunction with ROUGHNESS; controls the        brightness of the specular highlight; default value is 0.0  roughness       controls specular highlights in conjunction with SPECULAR; controls the        size of the specular highlight, small values make small, tight specular        highlights; default value is 0.05  reflection       amount the surface reflects; generally reflection and diffuse should        be inversely proportional; default value is 0.0  irid_amount       amount of contribution of iridescence to overall surface color, usually        0.1 to 0.5 is sufficient; iridescence is not used by default, but if any        iridescence property is set it is used; default value is 0.35  irid_thickness       thickness affects busyness of the iridescence, 0.25 to 1.0 yields best        results; iridescence is not used by default, but if any iridescence        property is set it is used; default value is 0.5  irid_turbulence       slightly difference way to affect thickness, 0.25 to 1.0 work best;        iridescence is not used by default, but if any iridescence property is        set it is used; default value is 0.5  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovrayfinish__define.html#visgrpovrayfinish::init", "visgrpovrayfinish::init", "routine in visgrpovrayfinish__define.pro", "visgrpovrayfinish__define.pro", "", "visgrpovrayfinish::init", " Create a finish.    ", "finish_name       name of a finish in finish.inc  ambient       controls the amount of ambient light that falls on the surface; increase        this amount to increase details in shadows; default value is 0.2  brilliance       controls the way that light intensity varies with incidence angle; the        default value is 1.0, higher values will cause the light to fall of less        at low and medium angles of incidence  diffuse       controls the amount of light from a light source falls on the surface;        low values of DIFFUSE will make the surface appear flat; default value        is 0.6  metallic       set to give the surface a more metallic appearance; default value is not        metallic  specular       controls specular highlights in conjunction with ROUGHNESS; controls the        brightness of the specular highlight; default value is 0.0  roughness       controls specular highlights in conjunction with SPECULAR; controls the        size of the specular highlight, small values make small, tight specular        highlights; default value is 0.05  reflection       amount the surface reflects; generally reflection and diffuse should        be inversely proportional; default value is 0.0  irid_amount       amount of contribution of iridescence to overall surface color, usually        0.1 to 0.5 is sufficient; iridescence is not used by default, but if any        iridescence property is set it is used; default value is 0.35  irid_thickness       thickness affects busyness of the iridescence, 0.25 to 1.0 yields best        results; iridescence is not used by default, but if any iridescence        property is set it is used; default value is 0.5  irid_turbulence       slightly difference way to affect thickness, 0.25 to 1.0 work best;        iridescence is not used by default, but if any iridescence property is        set it is used; default value is 0.5  ", "          -1", "    1 for success, 0 for failure  ");
  
  libdata[libdataItem++] = new Array("./visgrpovrayfinish__define.html#visgrpovrayfinish__define", "visgrpovrayfinish__define", "routine in visgrpovrayfinish__define.pro", "visgrpovrayfinish__define.pro", "", "visgrpovrayfinish__define", " Define instance variables.    ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovraygrid__define.html", "visgrpovraygrid__define.pro", ".pro file in ./ directory", "visgrpovraygrid__define.pro", "", "", " A grid represents a plane with a grid pattern on it.    See the following for a discussion of how the grid is implemented in POV-Ray:    http://tinyurl.com/4so8do   ", "", "object graphics", "    The following creates a light blue plane with while grid lines at y = ymin     with grid lines every 0.25 data units:    plane = obj_new('VISgrPOVRayGrid', $                   gridline_thick=0.05, $                   color=[200, 200, 255], $                   gridline_color=[255, 255, 255], $                   grid_size=[0.25, 0.25], $                   plane=[0, 1, 0, -ymin])      See the example attached to the end of this file as a main-level program     (only available if you have the source code version of this routine):    IDL&gt; .run visgrpovraygrid__define      This should produce:              * Add an IDL representation of the grid    ");
  
  
  libdata[libdataItem++] = new Array("./visgrpovraygrid__define.html#visgrpovraygrid::getProperty", "visgrpovraygrid::getProperty", "routine in visgrpovraygrid__define.pro", "visgrpovraygrid__define.pro", "", "visgrpovraygrid::getProperty", " Get properties.  ", "plane       equation of the plane [a, b, c, d] in the form:    ax + by + cz + d = 0   bottom       set to paint the grid lines on the other side of the plane; if the        grid lines do not show up on the plane, use /BOTTOM  gridline_color       color of grid lines as an RGB triplet  gridline_thick       thickness of grid lines, 1.0 is the width of the grid cell  gridline_shift       amount to shift the grid lines  grid_size       two-element array which is the size of the grid  _ref_extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraygrid__define.html#visgrpovraygrid::setProperty", "visgrpovraygrid::setProperty", "routine in visgrpovraygrid__define.pro", "visgrpovraygrid__define.pro", "", "visgrpovraygrid::setProperty", " Set properties.  ", "plane       equation of the plane [a, b, c, d] in the form:    ax + by + cz + d = 0   bottom       set to paint the grid lines on the other side of the plane; if the        grid lines do not show up on the plane, use /BOTTOM  gridline_color       color of grid lines as an RGB triplet  gridline_thick       thickness of grid lines, 1.0 is the width of the grid cell  gridline_shift       amount to shift the grid lines  grid_size       two-element array which is the size of the grid  _extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraygrid__define.html#visgrpovraygrid::cleanup", "visgrpovraygrid::cleanup", "routine in visgrpovraygrid__define.pro", "visgrpovraygrid__define.pro", "", "visgrpovraygrid::cleanup", " Free resources.  ", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraygrid__define.html#visgrpovraygrid::init", "visgrpovraygrid::init", "routine in visgrpovraygrid__define.pro", "visgrpovraygrid__define.pro", "", "visgrpovraygrid::init", " Create a POV-Ray grid object.    ", "plane       equation of the plane [a, b, c, d] in the form:    ax + by + cz + d = 0   bottom       set to paint the grid lines on the other side of the plane; if the        grid lines do not show up on the plane, use /BOTTOM  gridline_color       color of grid lines as an RGB triplet  gridline_thick       thickness of grid lines, 1.0 is the width of the grid cell  gridline_shift       amount to shift the grid lines  grid_size       two-element array which is the size of the grid  _extra", "          -1", "    1 for success, 0 for failure  ");
  
  libdata[libdataItem++] = new Array("./visgrpovraygrid__define.html#visgrpovraygrid__define", "visgrpovraygrid__define", "routine in visgrpovraygrid__define.pro", "visgrpovraygrid__define.pro", "", "visgrpovraygrid__define", " Define instance variables.    ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovraylight__define.html", "visgrpovraylight__define.pro", ".pro file in ./ directory", "visgrpovraylight__define.pro", "", "", " Any IDL type of light source plus the POV-Ray area light.    ", "", "object graphics", "    To create an area light:    light = obj_new('VISgrPOVRayLight', type=2, location=[0, 5, 5], $                   intensity=2.0, $                   /arealight, $                   width_axis=[0.3, 0, 0], height_axis=[0, 0.3, 0], $                   n_width_light=5, n_height_lights=5, $                   adaptive=1.0, /jitter)      This light is actually a 5 by 5 grid of lights spanning 0.3 units in the     x direction and 0.3 units in the y direction (although each light is moved     slightly by the JITTER keyword). This creates softer shadows.       See the example attached to the end of this file as a main-level program     (only available if you have the source code version of this routine):    IDL&gt; .run visgrpovraylight__define      This should produce output with an area light (which makes a fuzzy     shadow):           ");
  
  
  libdata[libdataItem++] = new Array("./visgrpovraylight__define.html#visgrpovraylight::getProperty", "visgrpovraylight::getProperty", "routine in visgrpovraylight__define.pro", "visgrpovraylight__define.pro", "", "visgrpovraylight::getProperty", " Get properties.  ", "arealight       set to use an area light  width_axis       vector representing width of area light  height_axis       vector representing height of area light  n_width_lights       number of lights along width axis  n_height_lights       number of lights along height axis  adaptive       adaptive value  jitter       set to use jitter  _ref_extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraylight__define.html#visgrpovraylight::setProperty", "visgrpovraylight::setProperty", "routine in visgrpovraylight__define.pro", "visgrpovraylight__define.pro", "", "visgrpovraylight::setProperty", " Set properties.  ", "arealight       set to use an area light  width_axis       vector representing width of area light  height_axis       vector representing height of area light  n_width_lights       number of lights along width axis  n_height_lights       number of lights along height axis  adaptive       adaptive value  jitter       set to use jitter  _extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraylight__define.html#visgrpovraylight::init", "visgrpovraylight::init", "routine in visgrpovraylight__define.pro", "visgrpovraylight__define.pro", "", "visgrpovraylight::init", " Create a light object.    ", "arealight       set to use an area light  width_axis       vector representing width of area light  height_axis       vector representing height of area light  n_width_lights       number of lights along width axis  n_height_lights       number of lights along height axis  adaptive       adaptive value  jitter       set to use jitter  _extra", "          -1", "    1 for success, 0 for failure  ");
  
  libdata[libdataItem++] = new Array("./visgrpovraylight__define.html#visgrpovraylight__define", "visgrpovraylight__define", "routine in visgrpovraylight__define.pro", "visgrpovraylight__define.pro", "", "visgrpovraylight__define", " Define instance variables.    ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovraypolygon__define.html", "visgrpovraypolygon__define.pro", ".pro file in ./ directory", "visgrpovraypolygon__define.pro", "", "", " A VISgrPOVRayPolygon represents a polygon with POV-Ray specific attributes  like the finish attribute class.    ", "", "object graphics", "");
  
  
  libdata[libdataItem++] = new Array("./visgrpovraypolygon__define.html#visgrpovraypolygon::getProperty", "visgrpovraypolygon::getProperty", "routine in visgrpovraypolygon__define.pro", "visgrpovraypolygon__define.pro", "", "visgrpovraypolygon::getProperty", " Get properties.  ", "finish       IDLgrPOVRayFinish attribute object for the polygon  _ref_extra       properties of IDLgrPolygon  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraypolygon__define.html#visgrpovraypolygon::setProperty", "visgrpovraypolygon::setProperty", "routine in visgrpovraypolygon__define.pro", "visgrpovraypolygon__define.pro", "", "visgrpovraypolygon::setProperty", " Set properties.  ", "finish       IDLgrPOVRayFinish attribute object for the polygon  _ref_extra       properties of IDLgrPolygon  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraypolygon__define.html#visgrpovraypolygon::cleanup", "visgrpovraypolygon::cleanup", "routine in visgrpovraypolygon__define.pro", "visgrpovraypolygon__define.pro", "", "visgrpovraypolygon::cleanup", " Free resources.  ", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraypolygon__define.html#visgrpovraypolygon::init", "visgrpovraypolygon::init", "routine in visgrpovraypolygon__define.pro", "visgrpovraypolygon__define.pro", "", "visgrpovraypolygon::init", " Create visgrpovraypolygon object.    ", "finish       IDLgrPOVRayFinish attribute object for the polygon  _extra       properties of IDLgrPolygon  x       x-coordinates of vertices of the polygon  y       y-coordinates of vertices of the polygon  z       z-coordinates of vertices of the polygon  ", "          -1", "    1 for success, 0 for failure    ");
  
  libdata[libdataItem++] = new Array("./visgrpovraypolygon__define.html#visgrpovraypolygon__define", "visgrpovraypolygon__define", "routine in visgrpovraypolygon__define.pro", "visgrpovraypolygon__define.pro", "", "visgrpovraypolygon__define", " Define instance variables.    ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovraytubes__define.html", "visgrpovraytubes__define.pro", ".pro file in ./ directory", "visgrpovraytubes__define.pro", "", "", " Represents a polyline in 3-dimensions by a series of cones.    ", "", "object graphics", "    To create some tubes to visualize streamlines of a vector field:    streamlines = obj_new('VISgrPOVRayTubes', data=verts, polylines=conn, $                         /open, radius=0.5 - 0.5 / (findgen(nverts) + 1.1), $                         color=[r[mag], g[mag], b[mag]])      See the example attached to the end of this file as a main-level program     (only available if you have the source code version of this routine):    IDL&gt; .run visgrpovraytubes__define      This should produce:           ");
  
  
  libdata[libdataItem++] = new Array("./visgrpovraytubes__define.html#visgrpovraytubes::getProperty", "visgrpovraytubes::getProperty", "routine in visgrpovraytubes__define.pro", "visgrpovraytubes__define.pro", "", "visgrpovraytubes::getProperty", " Get properties.  ", "open       set to control whether the ends are open or closed  radius       radius of the cones; either a scalar or a fltarr(n) where there are n        points in the polyline; default value is 1.0  _ref_extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraytubes__define.html#visgrpovraytubes::setProperty", "visgrpovraytubes::setProperty", "routine in visgrpovraytubes__define.pro", "visgrpovraytubes__define.pro", "", "visgrpovraytubes::setProperty", " Set properties.  ", "open       set to control whether the ends are open or closed  radius       radius of the cones; either a scalar or a fltarr(n) where there are n        points in the polyline; default value is 1.0  _extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraytubes__define.html#visgrpovraytubes::cleanup", "visgrpovraytubes::cleanup", "routine in visgrpovraytubes__define.pro", "visgrpovraytubes__define.pro", "", "visgrpovraytubes::cleanup", " Free resources.  ", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraytubes__define.html#visgrpovraytubes::init", "visgrpovraytubes::init", "routine in visgrpovraytubes__define.pro", "visgrpovraytubes__define.pro", "", "visgrpovraytubes::init", " Create a POV-Ray tube object.    ", "open       set to control whether the ends are open or closed  radius       radius of the cones; either a scalar or a fltarr(n) where there are n        points in the polyline; default value is 1.0  _extra", "          -1", "    1 for success, 0 for failure  ");
  
  libdata[libdataItem++] = new Array("./visgrpovraytubes__define.html#visgrpovraytubes__define", "visgrpovraytubes__define", "routine in visgrpovraytubes__define.pro", "visgrpovraytubes__define.pro", "", "visgrpovraytubes__define", " Define instance variables.    ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovrayview__define.html", "visgrpovrayview__define.pro", ".pro file in ./ directory", "visgrpovrayview__define.pro", "", "", " Controls top-level properties of the POV-Ray scene like focal blur.    ", "", "object graphics", "    Focal blur can be set up by setting the APERTURE and BLUR_SAMPLES keywords     when creating the view:    view = obj_new('VISgrPOVRayView', name='view', color=[200, 200, 255], $                  aperture=0.4, blur_samples=20L)      The FOCAL_POINT can be set later when the coordinate transformations are     known since the coordinates of the FOCAL_POINT are in view coordinates,     not data coordinates:    view-&gt;setProperty, focal_point=vis_transformpoint([0.52, 0.317, 0.0], cow)      See the example attached to the end of this file as a main-level program     (only available if you have the source code version of this routine):    IDL&gt; .run visgrpovrayview__define      This should produce output with a focal blur (focus is on the cow's head):           ");
  
  
  libdata[libdataItem++] = new Array("./visgrpovrayview__define.html#visgrpovrayview::getProperty", "visgrpovrayview::getProperty", "routine in visgrpovrayview__define.pro", "visgrpovrayview__define.pro", "", "visgrpovrayview::getProperty", " Get properties.  ", "focal_point       point which the camera focuses in view coordinates (not data        coordinates)  aperture       aperature of camera (small aperature value gives a larger depth of        field)  blur_samples      number of rays used to sample each pixel in POV-Ray  _ref_extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovrayview__define.html#visgrpovrayview::setProperty", "visgrpovrayview::setProperty", "routine in visgrpovrayview__define.pro", "visgrpovrayview__define.pro", "", "visgrpovrayview::setProperty", " Set properties.  ", "focal_point       point which the camera focuses in view coordinates (not data        coordinates)  aperture       aperature of camera (small aperature value gives a larger depth of        field)  blur_samples      number of rays used to sample each pixel in POV-Ray  _extra", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovrayview__define.html#visgrpovrayview::init", "visgrpovrayview::init", "routine in visgrpovrayview__define.pro", "visgrpovrayview__define.pro", "", "visgrpovrayview::init", " Create a POV-Ray view object.    ", "focal_point       point which the camera focuses in view coordinates (not data        coordinates)  aperture       aperature of camera (small aperature value gives a larger depth of        field)  blur_samples      number of rays used to sample each pixel in POV-Ray  _extra", "          -1", "    1 for success, 0 for failure  ");
  
  libdata[libdataItem++] = new Array("./visgrpovrayview__define.html#visgrpovrayview__define", "visgrpovrayview__define", "routine in visgrpovrayview__define.pro", "visgrpovrayview__define.pro", "", "visgrpovrayview__define", " Define instance variables.  ", "", "          -1", "");
  
  

libdata[libdataItem++] = new Array("./visgrpovraywindow__define.html", "visgrpovraywindow__define.pro", ".pro file in ./ directory", "visgrpovraywindow__define.pro", "", "", " Destination class graphics window like IDLgrWindow that uses POVRay to  render the graphics.    ", "", "          -1", "");
  
  
  libdata[libdataItem++] = new Array("./visgrpovraywindow__define.html#visgrpovraywindow::draw", "visgrpovraywindow::draw", "routine in visgrpovraywindow__define.pro", "visgrpovraywindow__define.pro", "", "visgrpovraywindow::draw", " Draws graphics hierarchy to the window using VISgrPOVRay.s    ", "picture       IDLgrScene, IDLgrViewGroup, or IDLgrView rooting object graphics        hierarchy to draw; required if GRAPHICS_TREE property is not set  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraywindow__define.html#visgrpovraywindow::getProperty", "visgrpovraywindow::getProperty", "routine in visgrpovraywindow__define.pro", "visgrpovraywindow__define.pro", "", "visgrpovraywindow::getProperty", " Get properties.  ", "_ref_extra       keywords to VISgrPOVRay and IDLgrWindow  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraywindow__define.html#visgrpovraywindow::setProperty", "visgrpovraywindow::setProperty", "routine in visgrpovraywindow__define.pro", "visgrpovraywindow__define.pro", "", "visgrpovraywindow::setProperty", " Set properties.  ", "_extra       keywords to VISgrPOVRay and IDLgrWindow  ", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraywindow__define.html#visgrpovraywindow::cleanup", "visgrpovraywindow::cleanup", "routine in visgrpovraywindow__define.pro", "visgrpovraywindow__define.pro", "", "visgrpovraywindow::cleanup", " Free resources.  ", "", "          -1", "");
  
  libdata[libdataItem++] = new Array("./visgrpovraywindow__define.html#visgrpovraywindow::init", "visgrpovraywindow::init", "routine in visgrpovraywindow__define.pro", "visgrpovraywindow__define.pro", "", "visgrpovraywindow::init", " Create a VISgrPOVRayWindow instance.    ", "file_prefixkeep_files_extra       keywords to VISgrPOVRay and IDLgrWindow  ", "          -1", "    1 for success, 0 for failure  ");
  
  libdata[libdataItem++] = new Array("./visgrpovraywindow__define.html#visgrpovraywindow__define", "visgrpovraywindow__define", "routine in visgrpovraywindow__define.pro", "visgrpovraywindow__define.pro", "", "visgrpovraywindow__define", " Define instance variables.    ", "", "          -1", "");
  
  

